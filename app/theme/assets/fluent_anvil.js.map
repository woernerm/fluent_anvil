{"mappings":"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","sources":["node_modules/@fluent/dom/esm/overlay.js","node_modules/cached-iterable/src/cached_iterable.mjs","node_modules/cached-iterable/src/cached_sync_iterable.mjs","node_modules/cached-iterable/src/cached_async_iterable.mjs","node_modules/@fluent/dom/esm/localization.js","node_modules/@fluent/dom/esm/dom_localization.js","node_modules/@fluent/bundle/esm/types.js","node_modules/@fluent/bundle/esm/resolver.js","node_modules/@fluent/bundle/esm/scope.js","node_modules/@fluent/bundle/esm/builtins.js","node_modules/@fluent/bundle/esm/memoizer.js","node_modules/@fluent/bundle/esm/bundle.js","node_modules/@fluent/bundle/esm/resource.js","node_modules/lodash.memoize/index.js","node_modules/get-user-locale/dist/esm/index.js","src/fluent_anvil.js"],"sourcesContent":["/* eslint no-console: [\"error\", {allow: [\"warn\"]}] */\n/* global console */\n// Match the opening angle bracket (<) in HTML tags, and HTML entities like\n// &amp;, &#0038;, &#x0026;.\nconst reOverlay = /<|&#?\\w+;/;\n/**\n * Elements allowed in translations even if they are not present in the source\n * HTML. They are text-level elements as defined by the HTML5 spec:\n * https://www.w3.org/TR/html5/text-level-semantics.html with the exception of:\n *\n *   - a - because we don't allow href on it anyways,\n *   - ruby, rt, rp - because we don't allow nested elements to be inserted.\n */\nconst TEXT_LEVEL_ELEMENTS = {\n    \"http://www.w3.org/1999/xhtml\": [\n        \"em\", \"strong\", \"small\", \"s\", \"cite\", \"q\", \"dfn\", \"abbr\", \"data\",\n        \"time\", \"code\", \"var\", \"samp\", \"kbd\", \"sub\", \"sup\", \"i\", \"b\", \"u\",\n        \"mark\", \"bdi\", \"bdo\", \"span\", \"br\", \"wbr\"\n    ],\n};\nconst LOCALIZABLE_ATTRIBUTES = {\n    \"http://www.w3.org/1999/xhtml\": {\n        global: [\"title\", \"aria-label\", \"aria-valuetext\"],\n        a: [\"download\"],\n        area: [\"download\", \"alt\"],\n        // value is special-cased in isAttrNameLocalizable\n        input: [\"alt\", \"placeholder\"],\n        menuitem: [\"label\"],\n        menu: [\"label\"],\n        optgroup: [\"label\"],\n        option: [\"label\"],\n        track: [\"label\"],\n        img: [\"alt\"],\n        textarea: [\"placeholder\"],\n        th: [\"abbr\"]\n    },\n    \"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul\": {\n        global: [\n            \"accesskey\", \"aria-label\", \"aria-valuetext\", \"label\",\n            \"title\", \"tooltiptext\"\n        ],\n        description: [\"value\"],\n        key: [\"key\", \"keycode\"],\n        label: [\"value\"],\n        textbox: [\"placeholder\", \"value\"],\n    }\n};\n/**\n * Translate an element.\n *\n * Translate the element's text content and attributes. Some HTML markup is\n * allowed in the translation. The element's children with the data-l10n-name\n * attribute will be treated as arguments to the translation. If the\n * translation defines the same children, their attributes and text contents\n * will be used for translating the matching source child.\n *\n * @param   {Element} element\n * @param   {Object} translation\n * @private\n */\nexport default function translateElement(element, translation) {\n    const { value } = translation;\n    if (typeof value === \"string\") {\n        if (element.localName === \"title\" &&\n            element.namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n            // A special case for the HTML title element whose content must be text.\n            element.textContent = value;\n        }\n        else if (!reOverlay.test(value)) {\n            // If the translation doesn't contain any markup skip the overlay logic.\n            element.textContent = value;\n        }\n        else {\n            // Else parse the translation's HTML using an inert template element,\n            // sanitize it and replace the element's content.\n            const templateElement = element.ownerDocument.createElementNS(\"http://www.w3.org/1999/xhtml\", \"template\");\n            templateElement.innerHTML = value;\n            overlayChildNodes(templateElement.content, element);\n        }\n    }\n    // Even if the translation doesn't define any localizable attributes, run\n    // overlayAttributes to remove any localizable attributes set by previous\n    // translations.\n    overlayAttributes(translation, element);\n}\n/**\n * Replace child nodes of an element with child nodes of another element.\n *\n * The contents of the target element will be cleared and fully replaced with\n * sanitized contents of the source element.\n *\n * @param {DocumentFragment} fromFragment - The source of children to overlay.\n * @param {Element} toElement - The target of the overlay.\n * @private\n */\nfunction overlayChildNodes(fromFragment, toElement) {\n    for (const childNode of fromFragment.childNodes) {\n        if (childNode.nodeType === childNode.TEXT_NODE) {\n            // Keep the translated text node.\n            continue;\n        }\n        if (childNode.hasAttribute(\"data-l10n-name\")) {\n            const sanitized = getNodeForNamedElement(toElement, childNode);\n            fromFragment.replaceChild(sanitized, childNode);\n            continue;\n        }\n        if (isElementAllowed(childNode)) {\n            const sanitized = createSanitizedElement(childNode);\n            fromFragment.replaceChild(sanitized, childNode);\n            continue;\n        }\n        console.warn(`An element of forbidden type \"${childNode.localName}\" was found in ` +\n            \"the translation. Only safe text-level elements and elements with \" +\n            \"data-l10n-name are allowed.\");\n        // If all else fails, replace the element with its text content.\n        fromFragment.replaceChild(createTextNodeFromTextContent(childNode), childNode);\n    }\n    toElement.textContent = \"\";\n    toElement.appendChild(fromFragment);\n}\nfunction hasAttribute(attributes, name) {\n    if (!attributes) {\n        return false;\n    }\n    for (let attr of attributes) {\n        if (attr.name === name) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Transplant localizable attributes of an element to another element.\n *\n * Any localizable attributes already set on the target element will be\n * cleared.\n *\n * @param   {Element|Object} fromElement - The source of child nodes to overlay.\n * @param   {Element} toElement - The target of the overlay.\n * @private\n */\nfunction overlayAttributes(fromElement, toElement) {\n    const explicitlyAllowed = toElement.hasAttribute(\"data-l10n-attrs\")\n        ? toElement.getAttribute(\"data-l10n-attrs\")\n            .split(\",\").map(i => i.trim())\n        : null;\n    // Remove existing localizable attributes if they\n    // will not be used in the new translation.\n    for (const attr of Array.from(toElement.attributes)) {\n        if (isAttrNameLocalizable(attr.name, toElement, explicitlyAllowed)\n            && !hasAttribute(fromElement.attributes, attr.name)) {\n            toElement.removeAttribute(attr.name);\n        }\n    }\n    // fromElement might be a {value, attributes} object as returned by\n    // Localization.messageFromBundle. In which case attributes may be null to\n    // save GC cycles.\n    if (!fromElement.attributes) {\n        return;\n    }\n    // Set localizable attributes.\n    for (const attr of Array.from(fromElement.attributes)) {\n        if (isAttrNameLocalizable(attr.name, toElement, explicitlyAllowed)\n            && toElement.getAttribute(attr.name) !== attr.value) {\n            toElement.setAttribute(attr.name, attr.value);\n        }\n    }\n}\n/**\n * Sanitize a child element created by the translation.\n *\n * Try to find a corresponding child in sourceElement and use it as the base\n * for the sanitization. This will preserve functional attribtues defined on\n * the child element in the source HTML.\n *\n * @param   {Element} sourceElement - The source for data-l10n-name lookups.\n * @param   {Element} translatedChild - The translated child to be sanitized.\n * @returns {Element}\n * @private\n */\nfunction getNodeForNamedElement(sourceElement, translatedChild) {\n    const childName = translatedChild.getAttribute(\"data-l10n-name\");\n    const sourceChild = sourceElement.querySelector(`[data-l10n-name=\"${childName}\"]`);\n    if (!sourceChild) {\n        console.warn(`An element named \"${childName}\" wasn't found in the source.`);\n        return createTextNodeFromTextContent(translatedChild);\n    }\n    if (sourceChild.localName !== translatedChild.localName) {\n        console.warn(`An element named \"${childName}\" was found in the translation ` +\n            `but its type ${translatedChild.localName} didn't match the ` +\n            `element found in the source (${sourceChild.localName}).`);\n        return createTextNodeFromTextContent(translatedChild);\n    }\n    // Remove it from sourceElement so that the translation cannot use\n    // the same reference name again.\n    sourceElement.removeChild(sourceChild);\n    // We can't currently guarantee that a translation won't remove\n    // sourceChild from the element completely, which could break the app if\n    // it relies on an event handler attached to the sourceChild. Let's make\n    // this limitation explicit for now by breaking the identitiy of the\n    // sourceChild by cloning it. This will destroy all event handlers\n    // attached to sourceChild via addEventListener and via on<name>\n    // properties.\n    const clone = sourceChild.cloneNode(false);\n    return shallowPopulateUsing(translatedChild, clone);\n}\n/**\n * Sanitize an allowed element.\n *\n * Text-level elements allowed in translations may only use safe attributes\n * and will have any nested markup stripped to text content.\n *\n * @param   {Element} element - The element to be sanitized.\n * @returns {Element}\n * @private\n */\nfunction createSanitizedElement(element) {\n    // Start with an empty element of the same type to remove nested children\n    // and non-localizable attributes defined by the translation.\n    const clone = element.ownerDocument.createElement(element.localName);\n    return shallowPopulateUsing(element, clone);\n}\n/**\n * Convert an element to a text node.\n *\n * @param   {Element} element - The element to be sanitized.\n * @returns {Node}\n * @private\n */\nfunction createTextNodeFromTextContent(element) {\n    return element.ownerDocument.createTextNode(element.textContent);\n}\n/**\n * Check if element is allowed in the translation.\n *\n * This method is used by the sanitizer when the translation markup contains\n * an element which is not present in the source code.\n *\n * @param   {Element} element\n * @returns {boolean}\n * @private\n */\nfunction isElementAllowed(element) {\n    const allowed = TEXT_LEVEL_ELEMENTS[element.namespaceURI];\n    return allowed && allowed.includes(element.localName);\n}\n/**\n * Check if attribute is allowed for the given element.\n *\n * This method is used by the sanitizer when the translation markup contains\n * DOM attributes, or when the translation has traits which map to DOM\n * attributes.\n *\n * `explicitlyAllowed` can be passed as a list of attributes explicitly\n * allowed on this element.\n *\n * @param   {string}         name\n * @param   {Element}        element\n * @param   {Array}          explicitlyAllowed\n * @returns {boolean}\n * @private\n */\nfunction isAttrNameLocalizable(name, element, explicitlyAllowed = null) {\n    if (explicitlyAllowed && explicitlyAllowed.includes(name)) {\n        return true;\n    }\n    const allowed = LOCALIZABLE_ATTRIBUTES[element.namespaceURI];\n    if (!allowed) {\n        return false;\n    }\n    const attrName = name.toLowerCase();\n    const elemName = element.localName;\n    // Is it a globally safe attribute?\n    if (allowed.global.includes(attrName)) {\n        return true;\n    }\n    // Are there no allowed attributes for this element?\n    if (!allowed[elemName]) {\n        return false;\n    }\n    // Is it allowed on this element?\n    if (allowed[elemName].includes(attrName)) {\n        return true;\n    }\n    // Special case for value on HTML inputs with type button, reset, submit\n    if (element.namespaceURI === \"http://www.w3.org/1999/xhtml\" &&\n        elemName === \"input\" && attrName === \"value\") {\n        const type = element.type.toLowerCase();\n        if (type === \"submit\" || type === \"button\" || type === \"reset\") {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Helper to set textContent and localizable attributes on an element.\n *\n * @param   {Element} fromElement\n * @param   {Element} toElement\n * @returns {Element}\n * @private\n */\nfunction shallowPopulateUsing(fromElement, toElement) {\n    toElement.textContent = fromElement.textContent;\n    overlayAttributes(fromElement, toElement);\n    return toElement;\n}\n","/*\n * Base CachedIterable class.\n */\nexport default class CachedIterable extends Array {\n    /**\n     * Create a `CachedIterable` instance from an iterable or, if another\n     * instance of `CachedIterable` is passed, return it without any\n     * modifications.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedIterable}\n     */\n    static from(iterable) {\n        if (iterable instanceof this) {\n            return iterable;\n        }\n\n        return new this(iterable);\n    }\n}\n","import CachedIterable from \"./cached_iterable.mjs\";\n\n/*\n * CachedSyncIterable caches the elements yielded by an iterable.\n *\n * It can be used to iterate over an iterable many times without depleting the\n * iterable.\n */\nexport default class CachedSyncIterable extends CachedIterable {\n    /**\n     * Create an `CachedSyncIterable` instance.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedSyncIterable}\n     */\n    constructor(iterable) {\n        super();\n\n        if (Symbol.iterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.iterator]();\n        } else {\n            throw new TypeError(\"Argument must implement the iteration protocol.\");\n        }\n    }\n\n    [Symbol.iterator]() {\n        const cached = this;\n        let cur = 0;\n\n        return {\n            next() {\n                if (cached.length <= cur) {\n                    cached.push(cached.iterator.next());\n                }\n                return cached[cur++];\n            }\n        };\n    }\n\n    /**\n     * This method allows user to consume the next element from the iterator\n     * into the cache.\n     *\n     * @param {number} count - number of elements to consume\n     */\n    touchNext(count = 1) {\n        let idx = 0;\n        while (idx++ < count) {\n            const last = this[this.length - 1];\n            if (last && last.done) {\n                break;\n            }\n            this.push(this.iterator.next());\n        }\n        // Return the last cached {value, done} object to allow the calling\n        // code to decide if it needs to call touchNext again.\n        return this[this.length - 1];\n    }\n}\n","import CachedIterable from \"./cached_iterable.mjs\";\n\n/*\n * CachedAsyncIterable caches the elements yielded by an async iterable.\n *\n * It can be used to iterate over an iterable many times without depleting the\n * iterable.\n */\nexport default class CachedAsyncIterable extends CachedIterable {\n    /**\n     * Create an `CachedAsyncIterable` instance.\n     *\n     * @param {Iterable} iterable\n     * @returns {CachedAsyncIterable}\n     */\n    constructor(iterable) {\n        super();\n\n        if (Symbol.asyncIterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.asyncIterator]();\n        } else if (Symbol.iterator in Object(iterable)) {\n            this.iterator = iterable[Symbol.iterator]();\n        } else {\n            throw new TypeError(\"Argument must implement the iteration protocol.\");\n        }\n    }\n\n    /**\n     * Asynchronous iterator caching the yielded elements.\n     *\n     * Elements yielded by the original iterable will be cached and available\n     * synchronously. Returns an async generator object implementing the\n     * iterator protocol over the elements of the original (async or sync)\n     * iterable.\n     */\n    [Symbol.asyncIterator]() {\n        const cached = this;\n        let cur = 0;\n\n        return {\n            async next() {\n                if (cached.length <= cur) {\n                    cached.push(cached.iterator.next());\n                }\n                return cached[cur++];\n            }\n        };\n    }\n\n    /**\n     * This method allows user to consume the next element from the iterator\n     * into the cache.\n     *\n     * @param {number} count - number of elements to consume\n     */\n    async touchNext(count = 1) {\n        let idx = 0;\n        while (idx++ < count) {\n            const last = this[this.length - 1];\n            if (last && (await last).done) {\n                break;\n            }\n            this.push(this.iterator.next());\n        }\n        // Return the last cached {value, done} object to allow the calling\n        // code to decide if it needs to call touchNext again.\n        return this[this.length - 1];\n    }\n}\n","/* eslint no-console: [\"error\", { allow: [\"warn\", \"error\"] }] */\n/* global console */\nimport { CachedAsyncIterable } from \"cached-iterable\";\n/**\n * The `Localization` class is a central high-level API for vanilla\n * JavaScript use of Fluent.\n * It combines language negotiation, FluentBundle and I/O to\n * provide a scriptable API to format translations.\n */\nexport default class Localization {\n    /**\n     * @param {Array<String>} resourceIds     - List of resource IDs\n     * @param {Function}      generateBundles - Function that returns a\n     *                                          generator over FluentBundles\n     *\n     * @returns {Localization}\n     */\n    constructor(resourceIds = [], generateBundles) {\n        this.resourceIds = resourceIds;\n        this.generateBundles = generateBundles;\n        this.onChange(true);\n    }\n    addResourceIds(resourceIds, eager = false) {\n        this.resourceIds.push(...resourceIds);\n        this.onChange(eager);\n        return this.resourceIds.length;\n    }\n    removeResourceIds(resourceIds) {\n        this.resourceIds = this.resourceIds.filter(r => !resourceIds.includes(r));\n        this.onChange();\n        return this.resourceIds.length;\n    }\n    /**\n     * Format translations and handle fallback if needed.\n     *\n     * Format translations for `keys` from `FluentBundle` instances on this\n     * DOMLocalization. In case of errors, fetch the next context in the\n     * fallback chain.\n     *\n     * @param   {Array<Object>}         keys    - Translation keys to format.\n     * @param   {Function}              method  - Formatting function.\n     * @returns {Promise<Array<string|Object>>}\n     * @private\n     */\n    async formatWithFallback(keys, method) {\n        const translations = [];\n        let hasAtLeastOneBundle = false;\n        for await (const bundle of this.bundles) {\n            hasAtLeastOneBundle = true;\n            const missingIds = keysFromBundle(method, bundle, keys, translations);\n            if (missingIds.size === 0) {\n                break;\n            }\n            if (typeof console !== \"undefined\") {\n                const locale = bundle.locales[0];\n                const ids = Array.from(missingIds).join(\", \");\n                console.warn(`[fluent] Missing translations in ${locale}: ${ids}`);\n            }\n        }\n        if (!hasAtLeastOneBundle && typeof console !== \"undefined\") {\n            // eslint-disable-next-line max-len\n            console.warn(`[fluent] Request for keys failed because no resource bundles got generated.\n  keys: ${JSON.stringify(keys)}.\n  resourceIds: ${JSON.stringify(this.resourceIds)}.`);\n        }\n        return translations;\n    }\n    /**\n     * Format translations into {value, attributes} objects.\n     *\n     * The fallback logic is the same as in `formatValues` but it returns {value,\n     * attributes} objects which are suitable for the translation of DOM\n     * elements.\n     *\n     *     docL10n.formatMessages([\n     *       {id: 'hello', args: { who: 'Mary' }},\n     *       {id: 'welcome'}\n     *     ]).then(console.log);\n     *\n     *     // [\n     *     //   { value: 'Hello, Mary!', attributes: null },\n     *     //   {\n     *     //     value: 'Welcome!',\n     *     //     attributes: [ { name: \"title\", value: 'Hello' } ]\n     *     //   }\n     *     // ]\n     *\n     * Returns a Promise resolving to an array of the translation strings.\n     *\n     * @param   {Array<Object>} keys\n     * @returns {Promise<Array<{value: string, attributes: Object}>>}\n     * @private\n     */\n    formatMessages(keys) {\n        return this.formatWithFallback(keys, messageFromBundle);\n    }\n    /**\n     * Retrieve translations corresponding to the passed keys.\n     *\n     * A generalized version of `DOMLocalization.formatValue`. Keys must\n     * be `{id, args}` objects.\n     *\n     *     docL10n.formatValues([\n     *       {id: 'hello', args: { who: 'Mary' }},\n     *       {id: 'hello', args: { who: 'John' }},\n     *       {id: 'welcome'}\n     *     ]).then(console.log);\n     *\n     *     // ['Hello, Mary!', 'Hello, John!', 'Welcome!']\n     *\n     * Returns a Promise resolving to an array of the translation strings.\n     *\n     * @param   {Array<Object>} keys\n     * @returns {Promise<Array<string>>}\n     */\n    formatValues(keys) {\n        return this.formatWithFallback(keys, valueFromBundle);\n    }\n    /**\n     * Retrieve the translation corresponding to the `id` identifier.\n     *\n     * If passed, `args` is a simple hash object with a list of variables that\n     * will be interpolated in the value of the translation.\n     *\n     *     docL10n.formatValue(\n     *       'hello', { who: 'world' }\n     *     ).then(console.log);\n     *\n     *     // 'Hello, world!'\n     *\n     * Returns a Promise resolving to the translation string.\n     *\n     * Use this sparingly for one-off messages which don't need to be\n     * retranslated when the user changes their language preferences, e.g. in\n     * notifications.\n     *\n     * @param   {string}  id     - Identifier of the translation to format\n     * @param   {Object}  [args] - Optional external arguments\n     * @returns {Promise<string>}\n     */\n    async formatValue(id, args) {\n        const [val] = await this.formatValues([{ id, args }]);\n        return val;\n    }\n    handleEvent() {\n        this.onChange();\n    }\n    /**\n     * This method should be called when there's a reason to believe\n     * that language negotiation or available resources changed.\n     */\n    onChange(eager = false) {\n        this.bundles = CachedAsyncIterable.from(this.generateBundles(this.resourceIds));\n        if (eager) {\n            this.bundles.touchNext(2);\n        }\n    }\n}\n/**\n * Format the value of a message into a string or `null`.\n *\n * This function is passed as a method to `keysFromBundle` and resolve\n * a value of a single L10n Entity using provided `FluentBundle`.\n *\n * If the message doesn't have a value, return `null`.\n *\n * @param   {FluentBundle} bundle\n * @param   {Array<Error>} errors\n * @param   {Object} message\n * @param   {Object} args\n * @returns {string|null}\n * @private\n */\nfunction valueFromBundle(bundle, errors, message, args) {\n    if (message.value) {\n        return bundle.formatPattern(message.value, args, errors);\n    }\n    return null;\n}\n/**\n * Format all public values of a message into a {value, attributes} object.\n *\n * This function is passed as a method to `keysFromBundle` and resolve\n * a single L10n Entity using provided `FluentBundle`.\n *\n * The function will return an object with a value and attributes of the\n * entity.\n *\n * @param   {FluentBundle} bundle\n * @param   {Array<Error>} errors\n * @param   {Object} message\n * @param   {Object} args\n * @returns {Object}\n * @private\n */\nfunction messageFromBundle(bundle, errors, message, args) {\n    const formatted = {\n        value: null,\n        attributes: null,\n    };\n    if (message.value) {\n        formatted.value = bundle.formatPattern(message.value, args, errors);\n    }\n    let attrNames = Object.keys(message.attributes);\n    if (attrNames.length > 0) {\n        formatted.attributes = new Array(attrNames.length);\n        for (let [i, name] of attrNames.entries()) {\n            let value = bundle.formatPattern(message.attributes[name], args, errors);\n            formatted.attributes[i] = { name, value };\n        }\n    }\n    return formatted;\n}\n/**\n * This function is an inner function for `Localization.formatWithFallback`.\n *\n * It takes a `FluentBundle`, list of l10n-ids and a method to be used for\n * key resolution (either `valueFromBundle` or `messageFromBundle`) and\n * optionally a value returned from `keysFromBundle` executed against\n * another `FluentBundle`.\n *\n * The idea here is that if the previous `FluentBundle` did not resolve\n * all keys, we're calling this function with the next context to resolve\n * the remaining ones.\n *\n * In the function, we loop over `keys` and check if we have the `prev`\n * passed and if it has an error entry for the position we're in.\n *\n * If it doesn't, it means that we have a good translation for this key and\n * we return it. If it does, we'll try to resolve the key using the passed\n * `FluentBundle`.\n *\n * In the end, we fill the translations array, and return the Set with\n * missing ids.\n *\n * See `Localization.formatWithFallback` for more info on how this is used.\n *\n * @param {Function}       method\n * @param {FluentBundle} bundle\n * @param {Array<string>}  keys\n * @param {{Array<{value: string, attributes: Object}>}} translations\n *\n * @returns {Set<string>}\n * @private\n */\nfunction keysFromBundle(method, bundle, keys, translations) {\n    const messageErrors = [];\n    const missingIds = new Set();\n    keys.forEach(({ id, args }, i) => {\n        if (translations[i] !== undefined) {\n            return;\n        }\n        let message = bundle.getMessage(id);\n        if (message) {\n            messageErrors.length = 0;\n            translations[i] = method(bundle, messageErrors, message, args);\n            if (messageErrors.length > 0 && typeof console !== \"undefined\") {\n                const locale = bundle.locales[0];\n                const errors = messageErrors.join(\", \");\n                // eslint-disable-next-line max-len\n                console.warn(`[fluent][resolver] errors in ${locale}/${id}: ${errors}.`);\n            }\n        }\n        else {\n            missingIds.add(id);\n        }\n    });\n    return missingIds;\n}\n","import translateElement from \"./overlay.js\";\nimport Localization from \"./localization.js\";\nconst L10NID_ATTR_NAME = \"data-l10n-id\";\nconst L10NARGS_ATTR_NAME = \"data-l10n-args\";\nconst L10N_ELEMENT_QUERY = `[${L10NID_ATTR_NAME}]`;\n/**\n * The `DOMLocalization` class is responsible for fetching resources and\n * formatting translations.\n *\n * It implements the fallback strategy in case of errors encountered during the\n * formatting of translations and methods for observing DOM\n * trees with a `MutationObserver`.\n */\nexport default class DOMLocalization extends Localization {\n    /**\n     * @param {Array<String>}    resourceIds     - List of resource IDs\n     * @param {Function}         generateBundles - Function that returns a\n     *                                             generator over FluentBundles\n     * @returns {DOMLocalization}\n     */\n    constructor(resourceIds, generateBundles) {\n        super(resourceIds, generateBundles);\n        // A Set of DOM trees observed by the `MutationObserver`.\n        this.roots = new Set();\n        // requestAnimationFrame handler.\n        this.pendingrAF = null;\n        // list of elements pending for translation.\n        this.pendingElements = new Set();\n        this.windowElement = null;\n        this.mutationObserver = null;\n        this.observerConfig = {\n            attributes: true,\n            characterData: false,\n            childList: true,\n            subtree: true,\n            attributeFilter: [L10NID_ATTR_NAME, L10NARGS_ATTR_NAME]\n        };\n    }\n    onChange(eager = false) {\n        super.onChange(eager);\n        if (this.roots) {\n            this.translateRoots();\n        }\n    }\n    /**\n     * Set the `data-l10n-id` and `data-l10n-args` attributes on DOM elements.\n     * FluentDOM makes use of mutation observers to detect changes\n     * to `data-l10n-*` attributes and translate elements asynchronously.\n     * `setAttributes` is a convenience method which allows to translate\n     * DOM elements declaratively.\n     *\n     * You should always prefer to use `data-l10n-id` on elements (statically in\n     * HTML or dynamically via `setAttributes`) over manually retrieving\n     * translations with `format`.  The use of attributes ensures that the\n     * elements can be retranslated when the user changes their language\n     * preferences.\n     *\n     * ```javascript\n     * localization.setAttributes(\n     *   document.querySelector('#welcome'), 'hello', { who: 'world' }\n     * );\n     * ```\n     *\n     * This will set the following attributes on the `#welcome` element.\n     * The MutationObserver will pick up this change and will localize the element\n     * asynchronously.\n     *\n     * ```html\n     * <p id='welcome'\n     *   data-l10n-id='hello'\n     *   data-l10n-args='{\"who\": \"world\"}'>\n     * </p>\n     * ```\n     *\n     * @param {Element}                element - Element to set attributes on\n     * @param {string}                 id      - l10n-id string\n     * @param {Object<string, string>} args    - KVP list of l10n arguments\n     * @returns {Element}\n     */\n    setAttributes(element, id, args) {\n        element.setAttribute(L10NID_ATTR_NAME, id);\n        if (args) {\n            element.setAttribute(L10NARGS_ATTR_NAME, JSON.stringify(args));\n        }\n        else {\n            element.removeAttribute(L10NARGS_ATTR_NAME);\n        }\n        return element;\n    }\n    /**\n     * Get the `data-l10n-*` attributes from DOM elements.\n     *\n     * ```javascript\n     * localization.getAttributes(\n     *   document.querySelector('#welcome')\n     * );\n     * // -> { id: 'hello', args: { who: 'world' } }\n     * ```\n     *\n     * @param   {Element}  element - HTML element\n     * @returns {{id: string, args: Object}}\n     */\n    getAttributes(element) {\n        return {\n            id: element.getAttribute(L10NID_ATTR_NAME),\n            args: JSON.parse(element.getAttribute(L10NARGS_ATTR_NAME) || null)\n        };\n    }\n    /**\n     * Add `newRoot` to the list of roots managed by this `DOMLocalization`.\n     *\n     * Additionally, if this `DOMLocalization` has an observer, start observing\n     * `newRoot` in order to translate mutations in it.\n     *\n     * @param {Element}      newRoot - Root to observe.\n     */\n    connectRoot(newRoot) {\n        for (const root of this.roots) {\n            if (root === newRoot ||\n                root.contains(newRoot) ||\n                newRoot.contains(root)) {\n                throw new Error(\"Cannot add a root that overlaps with existing root.\");\n            }\n        }\n        if (this.windowElement) {\n            if (this.windowElement !== newRoot.ownerDocument.defaultView) {\n                throw new Error(`Cannot connect a root:\n          DOMLocalization already has a root from a different window.`);\n            }\n        }\n        else {\n            this.windowElement = newRoot.ownerDocument.defaultView;\n            this.mutationObserver = new this.windowElement.MutationObserver(mutations => this.translateMutations(mutations));\n        }\n        this.roots.add(newRoot);\n        this.mutationObserver.observe(newRoot, this.observerConfig);\n    }\n    /**\n     * Remove `root` from the list of roots managed by this `DOMLocalization`.\n     *\n     * Additionally, if this `DOMLocalization` has an observer, stop observing\n     * `root`.\n     *\n     * Returns `true` if the root was the last one managed by this\n     * `DOMLocalization`.\n     *\n     * @param   {Element} root - Root to disconnect.\n     * @returns {boolean}\n     */\n    disconnectRoot(root) {\n        this.roots.delete(root);\n        // Pause the mutation observer to stop observing `root`.\n        this.pauseObserving();\n        if (this.roots.size === 0) {\n            this.mutationObserver = null;\n            this.windowElement = null;\n            this.pendingrAF = null;\n            this.pendingElements.clear();\n            return true;\n        }\n        // Resume observing all other roots.\n        this.resumeObserving();\n        return false;\n    }\n    /**\n     * Translate all roots associated with this `DOMLocalization`.\n     *\n     * @returns {Promise}\n     */\n    translateRoots() {\n        const roots = Array.from(this.roots);\n        return Promise.all(roots.map(root => this.translateFragment(root)));\n    }\n    /**\n     * Pauses the `MutationObserver`.\n     *\n     * @private\n     */\n    pauseObserving() {\n        if (!this.mutationObserver) {\n            return;\n        }\n        this.translateMutations(this.mutationObserver.takeRecords());\n        this.mutationObserver.disconnect();\n    }\n    /**\n     * Resumes the `MutationObserver`.\n     *\n     * @private\n     */\n    resumeObserving() {\n        if (!this.mutationObserver) {\n            return;\n        }\n        for (const root of this.roots) {\n            this.mutationObserver.observe(root, this.observerConfig);\n        }\n    }\n    /**\n     * Translate mutations detected by the `MutationObserver`.\n     *\n     * @private\n     */\n    translateMutations(mutations) {\n        for (const mutation of mutations) {\n            switch (mutation.type) {\n                case \"attributes\":\n                    if (mutation.target.hasAttribute(\"data-l10n-id\")) {\n                        this.pendingElements.add(mutation.target);\n                    }\n                    break;\n                case \"childList\":\n                    for (const addedNode of mutation.addedNodes) {\n                        if (addedNode.nodeType === addedNode.ELEMENT_NODE) {\n                            if (addedNode.childElementCount) {\n                                for (const element of this.getTranslatables(addedNode)) {\n                                    this.pendingElements.add(element);\n                                }\n                            }\n                            else if (addedNode.hasAttribute(L10NID_ATTR_NAME)) {\n                                this.pendingElements.add(addedNode);\n                            }\n                        }\n                    }\n                    break;\n            }\n        }\n        // This fragment allows us to coalesce all pending translations\n        // into a single requestAnimationFrame.\n        if (this.pendingElements.size > 0) {\n            if (this.pendingrAF === null) {\n                this.pendingrAF = this.windowElement.requestAnimationFrame(() => {\n                    this.translateElements(Array.from(this.pendingElements));\n                    this.pendingElements.clear();\n                    this.pendingrAF = null;\n                });\n            }\n        }\n    }\n    /**\n     * Translate a DOM element or fragment asynchronously using this\n     * `DOMLocalization` object.\n     *\n     * Manually trigger the translation (or re-translation) of a DOM fragment.\n     * Use the `data-l10n-id` and `data-l10n-args` attributes to mark up the DOM\n     * with information about which translations to use.\n     *\n     * Returns a `Promise` that gets resolved once the translation is complete.\n     *\n     * @param   {DOMFragment} frag - Element or DocumentFragment to be translated\n     * @returns {Promise}\n     */\n    translateFragment(frag) {\n        return this.translateElements(this.getTranslatables(frag));\n    }\n    /**\n     * Translate a list of DOM elements asynchronously using this\n     * `DOMLocalization` object.\n     *\n     * Manually trigger the translation (or re-translation) of a list of elements.\n     * Use the `data-l10n-id` and `data-l10n-args` attributes to mark up the DOM\n     * with information about which translations to use.\n     *\n     * Returns a `Promise` that gets resolved once the translation is complete.\n     *\n     * @param   {Array<Element>} elements - List of elements to be translated\n     * @returns {Promise}\n     */\n    async translateElements(elements) {\n        if (!elements.length) {\n            return undefined;\n        }\n        const keys = elements.map(this.getKeysForElement);\n        const translations = await this.formatMessages(keys);\n        return this.applyTranslations(elements, translations);\n    }\n    /**\n     * Applies translations onto elements.\n     *\n     * @param {Array<Element>} elements\n     * @param {Array<Object>}  translations\n     * @private\n     */\n    applyTranslations(elements, translations) {\n        this.pauseObserving();\n        for (let i = 0; i < elements.length; i++) {\n            if (translations[i] !== undefined) {\n                translateElement(elements[i], translations[i]);\n            }\n        }\n        this.resumeObserving();\n    }\n    /**\n     * Collects all translatable child elements of the element.\n     *\n     * @param {Element} element\n     * @returns {Array<Element>}\n     * @private\n     */\n    getTranslatables(element) {\n        const nodes = Array.from(element.querySelectorAll(L10N_ELEMENT_QUERY));\n        if (typeof element.hasAttribute === \"function\" &&\n            element.hasAttribute(L10NID_ATTR_NAME)) {\n            nodes.push(element);\n        }\n        return nodes;\n    }\n    /**\n     * Get the `data-l10n-*` attributes from DOM elements as a two-element\n     * array.\n     *\n     * @param {Element} element\n     * @returns {Object}\n     * @private\n     */\n    getKeysForElement(element) {\n        return {\n            id: element.getAttribute(L10NID_ATTR_NAME),\n            args: JSON.parse(element.getAttribute(L10NARGS_ATTR_NAME) || null)\n        };\n    }\n}\n","/**\n * The `FluentType` class is the base of Fluent's type system.\n *\n * Fluent types wrap JavaScript values and store additional configuration for\n * them, which can then be used in the `toString` method together with a proper\n * `Intl` formatter.\n */\nexport class FluentType {\n    /**\n     * Create a `FluentType` instance.\n     *\n     * @param value The JavaScript value to wrap.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Unwrap the raw value stored by this `FluentType`.\n     */\n    valueOf() {\n        return this.value;\n    }\n}\n/**\n * A `FluentType` representing no correct value.\n */\nexport class FluentNone extends FluentType {\n    /**\n     * Create an instance of `FluentNone` with an optional fallback value.\n     * @param value The fallback value of this `FluentNone`.\n     */\n    constructor(value = \"???\") {\n        super(value);\n    }\n    /**\n     * Format this `FluentNone` to the fallback string.\n     */\n    toString(scope) {\n        return `{${this.value}}`;\n    }\n}\n/**\n * A `FluentType` representing a number.\n *\n * A `FluentNumber` instance stores the number value of the number it\n * represents. It may also store an option bag of options which will be passed\n * to `Intl.NumerFormat` when the `FluentNumber` is formatted to a string.\n */\nexport class FluentNumber extends FluentType {\n    /**\n     * Create an instance of `FluentNumber` with options to the\n     * `Intl.NumberFormat` constructor.\n     *\n     * @param value The number value of this `FluentNumber`.\n     * @param opts Options which will be passed to `Intl.NumberFormat`.\n     */\n    constructor(value, opts = {}) {\n        super(value);\n        this.opts = opts;\n    }\n    /**\n     * Format this `FluentNumber` to a string.\n     */\n    toString(scope) {\n        try {\n            const nf = scope.memoizeIntlObject(Intl.NumberFormat, this.opts);\n            return nf.format(this.value);\n        }\n        catch (err) {\n            scope.reportError(err);\n            return this.value.toString(10);\n        }\n    }\n}\n/**\n * A `FluentType` representing a date and time.\n *\n * A `FluentDateTime` instance stores the number value of the date it\n * represents, as a numerical timestamp in milliseconds. It may also store an\n * option bag of options which will be passed to `Intl.DateTimeFormat` when the\n * `FluentDateTime` is formatted to a string.\n */\nexport class FluentDateTime extends FluentType {\n    /**\n     * Create an instance of `FluentDateTime` with options to the\n     * `Intl.DateTimeFormat` constructor.\n     *\n     * @param value The number value of this `FluentDateTime`, in milliseconds.\n     * @param opts Options which will be passed to `Intl.DateTimeFormat`.\n     */\n    constructor(value, opts = {}) {\n        super(value);\n        this.opts = opts;\n    }\n    /**\n     * Format this `FluentDateTime` to a string.\n     */\n    toString(scope) {\n        try {\n            const dtf = scope.memoizeIntlObject(Intl.DateTimeFormat, this.opts);\n            return dtf.format(this.value);\n        }\n        catch (err) {\n            scope.reportError(err);\n            return new Date(this.value).toISOString();\n        }\n    }\n}\n","/* global Intl */\n/**\n * @overview\n *\n * The role of the Fluent resolver is to format a `Pattern` to an instance of\n * `FluentValue`. For performance reasons, primitive strings are considered\n * such instances, too.\n *\n * Translations can contain references to other messages or variables,\n * conditional logic in form of select expressions, traits which describe their\n * grammatical features, and can use Fluent builtins which make use of the\n * `Intl` formatters to format numbers and dates into the bundle's languages.\n * See the documentation of the Fluent syntax for more information.\n *\n * In case of errors the resolver will try to salvage as much of the\n * translation as possible. In rare situations where the resolver didn't know\n * how to recover from an error it will return an instance of `FluentNone`.\n *\n * All expressions resolve to an instance of `FluentValue`. The caller should\n * use the `toString` method to convert the instance to a native value.\n *\n * Functions in this file pass around an instance of the `Scope` class, which\n * stores the data required for successful resolution and error recovery.\n */\nimport { FluentType, FluentNone, FluentNumber, FluentDateTime } from \"./types.js\";\n// The maximum number of placeables which can be expanded in a single call to\n// `formatPattern`. The limit protects against the Billion Laughs and Quadratic\n// Blowup attacks. See https://msdn.microsoft.com/en-us/magazine/ee335713.aspx.\nconst MAX_PLACEABLES = 100;\n// Unicode bidi isolation characters.\nconst FSI = \"\\u2068\";\nconst PDI = \"\\u2069\";\n// Helper: match a variant key to the given selector.\nfunction match(scope, selector, key) {\n    if (key === selector) {\n        // Both are strings.\n        return true;\n    }\n    // XXX Consider comparing options too, e.g. minimumFractionDigits.\n    if (key instanceof FluentNumber &&\n        selector instanceof FluentNumber &&\n        key.value === selector.value) {\n        return true;\n    }\n    if (selector instanceof FluentNumber && typeof key === \"string\") {\n        let category = scope\n            .memoizeIntlObject(Intl.PluralRules, selector.opts)\n            .select(selector.value);\n        if (key === category) {\n            return true;\n        }\n    }\n    return false;\n}\n// Helper: resolve the default variant from a list of variants.\nfunction getDefault(scope, variants, star) {\n    if (variants[star]) {\n        return resolvePattern(scope, variants[star].value);\n    }\n    scope.reportError(new RangeError(\"No default\"));\n    return new FluentNone();\n}\n// Helper: resolve arguments to a call expression.\nfunction getArguments(scope, args) {\n    const positional = [];\n    const named = Object.create(null);\n    for (const arg of args) {\n        if (arg.type === \"narg\") {\n            named[arg.name] = resolveExpression(scope, arg.value);\n        }\n        else {\n            positional.push(resolveExpression(scope, arg));\n        }\n    }\n    return { positional, named };\n}\n// Resolve an expression to a Fluent type.\nfunction resolveExpression(scope, expr) {\n    switch (expr.type) {\n        case \"str\":\n            return expr.value;\n        case \"num\":\n            return new FluentNumber(expr.value, {\n                minimumFractionDigits: expr.precision\n            });\n        case \"var\":\n            return resolveVariableReference(scope, expr);\n        case \"mesg\":\n            return resolveMessageReference(scope, expr);\n        case \"term\":\n            return resolveTermReference(scope, expr);\n        case \"func\":\n            return resolveFunctionReference(scope, expr);\n        case \"select\":\n            return resolveSelectExpression(scope, expr);\n        default:\n            return new FluentNone();\n    }\n}\n// Resolve a reference to a variable.\nfunction resolveVariableReference(scope, { name }) {\n    let arg;\n    if (scope.params) {\n        // We're inside a TermReference. It's OK to reference undefined parameters.\n        if (Object.prototype.hasOwnProperty.call(scope.params, name)) {\n            arg = scope.params[name];\n        }\n        else {\n            return new FluentNone(`$${name}`);\n        }\n    }\n    else if (scope.args\n        && Object.prototype.hasOwnProperty.call(scope.args, name)) {\n        // We're in the top-level Pattern or inside a MessageReference. Missing\n        // variables references produce ReferenceErrors.\n        arg = scope.args[name];\n    }\n    else {\n        scope.reportError(new ReferenceError(`Unknown variable: $${name}`));\n        return new FluentNone(`$${name}`);\n    }\n    // Return early if the argument already is an instance of FluentType.\n    if (arg instanceof FluentType) {\n        return arg;\n    }\n    // Convert the argument to a Fluent type.\n    switch (typeof arg) {\n        case \"string\":\n            return arg;\n        case \"number\":\n            return new FluentNumber(arg);\n        case \"object\":\n            if (arg instanceof Date) {\n                return new FluentDateTime(arg.getTime());\n            }\n        // eslint-disable-next-line no-fallthrough\n        default:\n            scope.reportError(new TypeError(`Variable type not supported: $${name}, ${typeof arg}`));\n            return new FluentNone(`$${name}`);\n    }\n}\n// Resolve a reference to another message.\nfunction resolveMessageReference(scope, { name, attr }) {\n    const message = scope.bundle._messages.get(name);\n    if (!message) {\n        scope.reportError(new ReferenceError(`Unknown message: ${name}`));\n        return new FluentNone(name);\n    }\n    if (attr) {\n        const attribute = message.attributes[attr];\n        if (attribute) {\n            return resolvePattern(scope, attribute);\n        }\n        scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));\n        return new FluentNone(`${name}.${attr}`);\n    }\n    if (message.value) {\n        return resolvePattern(scope, message.value);\n    }\n    scope.reportError(new ReferenceError(`No value: ${name}`));\n    return new FluentNone(name);\n}\n// Resolve a call to a Term with key-value arguments.\nfunction resolveTermReference(scope, { name, attr, args }) {\n    const id = `-${name}`;\n    const term = scope.bundle._terms.get(id);\n    if (!term) {\n        scope.reportError(new ReferenceError(`Unknown term: ${id}`));\n        return new FluentNone(id);\n    }\n    if (attr) {\n        const attribute = term.attributes[attr];\n        if (attribute) {\n            // Every TermReference has its own variables.\n            scope.params = getArguments(scope, args).named;\n            const resolved = resolvePattern(scope, attribute);\n            scope.params = null;\n            return resolved;\n        }\n        scope.reportError(new ReferenceError(`Unknown attribute: ${attr}`));\n        return new FluentNone(`${id}.${attr}`);\n    }\n    scope.params = getArguments(scope, args).named;\n    const resolved = resolvePattern(scope, term.value);\n    scope.params = null;\n    return resolved;\n}\n// Resolve a call to a Function with positional and key-value arguments.\nfunction resolveFunctionReference(scope, { name, args }) {\n    // Some functions are built-in. Others may be provided by the runtime via\n    // the `FluentBundle` constructor.\n    let func = scope.bundle._functions[name];\n    if (!func) {\n        scope.reportError(new ReferenceError(`Unknown function: ${name}()`));\n        return new FluentNone(`${name}()`);\n    }\n    if (typeof func !== \"function\") {\n        scope.reportError(new TypeError(`Function ${name}() is not callable`));\n        return new FluentNone(`${name}()`);\n    }\n    try {\n        let resolved = getArguments(scope, args);\n        return func(resolved.positional, resolved.named);\n    }\n    catch (err) {\n        scope.reportError(err);\n        return new FluentNone(`${name}()`);\n    }\n}\n// Resolve a select expression to the member object.\nfunction resolveSelectExpression(scope, { selector, variants, star }) {\n    let sel = resolveExpression(scope, selector);\n    if (sel instanceof FluentNone) {\n        return getDefault(scope, variants, star);\n    }\n    // Match the selector against keys of each variant, in order.\n    for (const variant of variants) {\n        const key = resolveExpression(scope, variant.key);\n        if (match(scope, sel, key)) {\n            return resolvePattern(scope, variant.value);\n        }\n    }\n    return getDefault(scope, variants, star);\n}\n// Resolve a pattern (a complex string with placeables).\nexport function resolveComplexPattern(scope, ptn) {\n    if (scope.dirty.has(ptn)) {\n        scope.reportError(new RangeError(\"Cyclic reference\"));\n        return new FluentNone();\n    }\n    // Tag the pattern as dirty for the purpose of the current resolution.\n    scope.dirty.add(ptn);\n    const result = [];\n    // Wrap interpolations with Directional Isolate Formatting characters\n    // only when the pattern has more than one element.\n    const useIsolating = scope.bundle._useIsolating && ptn.length > 1;\n    for (const elem of ptn) {\n        if (typeof elem === \"string\") {\n            result.push(scope.bundle._transform(elem));\n            continue;\n        }\n        scope.placeables++;\n        if (scope.placeables > MAX_PLACEABLES) {\n            scope.dirty.delete(ptn);\n            // This is a fatal error which causes the resolver to instantly bail out\n            // on this pattern. The length check protects against excessive memory\n            // usage, and throwing protects against eating up the CPU when long\n            // placeables are deeply nested.\n            throw new RangeError(`Too many placeables expanded: ${scope.placeables}, ` +\n                `max allowed is ${MAX_PLACEABLES}`);\n        }\n        if (useIsolating) {\n            result.push(FSI);\n        }\n        result.push(resolveExpression(scope, elem).toString(scope));\n        if (useIsolating) {\n            result.push(PDI);\n        }\n    }\n    scope.dirty.delete(ptn);\n    return result.join(\"\");\n}\n// Resolve a simple or a complex Pattern to a FluentString (which is really the\n// string primitive).\nfunction resolvePattern(scope, value) {\n    // Resolve a simple pattern.\n    if (typeof value === \"string\") {\n        return scope.bundle._transform(value);\n    }\n    return resolveComplexPattern(scope, value);\n}\n","export class Scope {\n    constructor(bundle, errors, args) {\n        /** The Set of patterns already encountered during this resolution.\n         * Used to detect and prevent cyclic resolutions. */\n        this.dirty = new WeakSet();\n        /** A dict of parameters passed to a TermReference. */\n        this.params = null;\n        /** The running count of placeables resolved so far. Used to detect the\n          * Billion Laughs and Quadratic Blowup attacks. */\n        this.placeables = 0;\n        this.bundle = bundle;\n        this.errors = errors;\n        this.args = args;\n    }\n    reportError(error) {\n        if (!this.errors || !(error instanceof Error)) {\n            throw error;\n        }\n        this.errors.push(error);\n    }\n    memoizeIntlObject(ctor, opts) {\n        let cache = this.bundle._intls.get(ctor);\n        if (!cache) {\n            cache = {};\n            this.bundle._intls.set(ctor, cache);\n        }\n        let id = JSON.stringify(opts);\n        if (!cache[id]) {\n            cache[id] = new ctor(this.bundle.locales, opts);\n        }\n        return cache[id];\n    }\n}\n","/**\n * @overview\n *\n * The FTL resolver ships with a number of functions built-in.\n *\n * Each function take two arguments:\n *   - args - an array of positional args\n *   - opts - an object of key-value args\n *\n * Arguments to functions are guaranteed to already be instances of\n * `FluentValue`.  Functions must return `FluentValues` as well.\n */\nimport { FluentNone, FluentNumber, FluentDateTime } from \"./types.js\";\nfunction values(opts, allowed) {\n    const unwrapped = Object.create(null);\n    for (const [name, opt] of Object.entries(opts)) {\n        if (allowed.includes(name)) {\n            unwrapped[name] = opt.valueOf();\n        }\n    }\n    return unwrapped;\n}\nconst NUMBER_ALLOWED = [\n    \"unitDisplay\",\n    \"currencyDisplay\",\n    \"useGrouping\",\n    \"minimumIntegerDigits\",\n    \"minimumFractionDigits\",\n    \"maximumFractionDigits\",\n    \"minimumSignificantDigits\",\n    \"maximumSignificantDigits\",\n];\n/**\n * The implementation of the `NUMBER()` builtin available to translations.\n *\n * Translations may call the `NUMBER()` builtin in order to specify formatting\n * options of a number. For example:\n *\n *     pi = The value of  is {NUMBER($pi, maximumFractionDigits: 2)}.\n *\n * The implementation expects an array of `FluentValues` representing the\n * positional arguments, and an object of named `FluentValues` representing the\n * named parameters.\n *\n * The following options are recognized:\n *\n *     unitDisplay\n *     currencyDisplay\n *     useGrouping\n *     minimumIntegerDigits\n *     minimumFractionDigits\n *     maximumFractionDigits\n *     minimumSignificantDigits\n *     maximumSignificantDigits\n *\n * Other options are ignored.\n *\n * @param args The positional arguments passed to this `NUMBER()`.\n * @param opts The named argments passed to this `NUMBER()`.\n */\nexport function NUMBER(args, opts) {\n    let arg = args[0];\n    if (arg instanceof FluentNone) {\n        return new FluentNone(`NUMBER(${arg.valueOf()})`);\n    }\n    if (arg instanceof FluentNumber) {\n        return new FluentNumber(arg.valueOf(), {\n            ...arg.opts,\n            ...values(opts, NUMBER_ALLOWED)\n        });\n    }\n    if (arg instanceof FluentDateTime) {\n        return new FluentNumber(arg.valueOf(), {\n            ...values(opts, NUMBER_ALLOWED)\n        });\n    }\n    throw new TypeError(\"Invalid argument to NUMBER\");\n}\nconst DATETIME_ALLOWED = [\n    \"dateStyle\",\n    \"timeStyle\",\n    \"fractionalSecondDigits\",\n    \"dayPeriod\",\n    \"hour12\",\n    \"weekday\",\n    \"era\",\n    \"year\",\n    \"month\",\n    \"day\",\n    \"hour\",\n    \"minute\",\n    \"second\",\n    \"timeZoneName\",\n];\n/**\n * The implementation of the `DATETIME()` builtin available to translations.\n *\n * Translations may call the `DATETIME()` builtin in order to specify\n * formatting options of a number. For example:\n *\n *     now = It's {DATETIME($today, month: \"long\")}.\n *\n * The implementation expects an array of `FluentValues` representing the\n * positional arguments, and an object of named `FluentValues` representing the\n * named parameters.\n *\n * The following options are recognized:\n *\n *     dateStyle\n *     timeStyle\n *     fractionalSecondDigits\n *     dayPeriod\n *     hour12\n *     weekday\n *     era\n *     year\n *     month\n *     day\n *     hour\n *     minute\n *     second\n *     timeZoneName\n *\n * Other options are ignored.\n *\n * @param args The positional arguments passed to this `DATETIME()`.\n * @param opts The named argments passed to this `DATETIME()`.\n */\nexport function DATETIME(args, opts) {\n    let arg = args[0];\n    if (arg instanceof FluentNone) {\n        return new FluentNone(`DATETIME(${arg.valueOf()})`);\n    }\n    if (arg instanceof FluentDateTime) {\n        return new FluentDateTime(arg.valueOf(), {\n            ...arg.opts,\n            ...values(opts, DATETIME_ALLOWED)\n        });\n    }\n    if (arg instanceof FluentNumber) {\n        return new FluentDateTime(arg.valueOf(), {\n            ...values(opts, DATETIME_ALLOWED)\n        });\n    }\n    throw new TypeError(\"Invalid argument to DATETIME\");\n}\n","const cache = new Map();\nexport function getMemoizerForLocale(locales) {\n    const stringLocale = Array.isArray(locales) ? locales.join(\" \") : locales;\n    let memoizer = cache.get(stringLocale);\n    if (memoizer === undefined) {\n        memoizer = new Map();\n        cache.set(stringLocale, memoizer);\n    }\n    return memoizer;\n}\n","import { resolveComplexPattern } from \"./resolver.js\";\nimport { Scope } from \"./scope.js\";\nimport { FluentNone } from \"./types.js\";\nimport { NUMBER, DATETIME } from \"./builtins.js\";\nimport { getMemoizerForLocale } from \"./memoizer.js\";\n/**\n * Message bundles are single-language stores of translation resources. They are\n * responsible for formatting message values and attributes to strings.\n */\nexport class FluentBundle {\n    /**\n     * Create an instance of `FluentBundle`.\n     *\n     * The `locales` argument is used to instantiate `Intl` formatters used by\n     * translations. The `options` object can be used to configure the bundle.\n     *\n     * Examples:\n     *\n     *     let bundle = new FluentBundle([\"en-US\", \"en\"]);\n     *\n     *     let bundle = new FluentBundle(locales, {useIsolating: false});\n     *\n     *     let bundle = new FluentBundle(locales, {\n     *       useIsolating: true,\n     *       functions: {\n     *         NODE_ENV: () => process.env.NODE_ENV\n     *       }\n     *     });\n     *\n     * Available options:\n     *\n     *   - `functions` - an object of additional functions available to\n     *     translations as builtins.\n     *\n     *   - `useIsolating` - boolean specifying whether to use Unicode isolation\n     *     marks (FSI, PDI) for bidi interpolations. Default: `true`.\n     *\n     *   - `transform` - a function used to transform string parts of patterns.\n     */\n    constructor(locales, { functions, useIsolating = true, transform = (v) => v } = {}) {\n        this._terms = new Map();\n        this._messages = new Map();\n        this.locales = Array.isArray(locales) ? locales : [locales];\n        this._functions = {\n            NUMBER,\n            DATETIME,\n            ...functions\n        };\n        this._useIsolating = useIsolating;\n        this._transform = transform;\n        this._intls = getMemoizerForLocale(locales);\n    }\n    /**\n     * Check if a message is present in the bundle.\n     *\n     * @param id - The identifier of the message to check.\n     */\n    hasMessage(id) {\n        return this._messages.has(id);\n    }\n    /**\n     * Return a raw unformatted message object from the bundle.\n     *\n     * Raw messages are `{value, attributes}` shapes containing translation units\n     * called `Patterns`. `Patterns` are implementation-specific; they should be\n     * treated as black boxes and formatted with `FluentBundle.formatPattern`.\n     *\n     * @param id - The identifier of the message to check.\n     */\n    getMessage(id) {\n        return this._messages.get(id);\n    }\n    /**\n     * Add a translation resource to the bundle.\n     *\n     * The translation resource must be an instance of `FluentResource`.\n     *\n     *     let res = new FluentResource(\"foo = Foo\");\n     *     bundle.addResource(res);\n     *     bundle.getMessage(\"foo\");\n     *     //  {value: .., attributes: {..}}\n     *\n     * Available options:\n     *\n     *   - `allowOverrides` - boolean specifying whether it's allowed to override\n     *     an existing message or term with a new value. Default: `false`.\n     *\n     * @param   res - FluentResource object.\n     * @param   options\n     */\n    addResource(res, { allowOverrides = false } = {}) {\n        const errors = [];\n        for (let i = 0; i < res.body.length; i++) {\n            let entry = res.body[i];\n            if (entry.id.startsWith(\"-\")) {\n                // Identifiers starting with a dash (-) define terms. Terms are private\n                // and cannot be retrieved from FluentBundle.\n                if (allowOverrides === false && this._terms.has(entry.id)) {\n                    errors.push(new Error(`Attempt to override an existing term: \"${entry.id}\"`));\n                    continue;\n                }\n                this._terms.set(entry.id, entry);\n            }\n            else {\n                if (allowOverrides === false && this._messages.has(entry.id)) {\n                    errors.push(new Error(`Attempt to override an existing message: \"${entry.id}\"`));\n                    continue;\n                }\n                this._messages.set(entry.id, entry);\n            }\n        }\n        return errors;\n    }\n    /**\n     * Format a `Pattern` to a string.\n     *\n     * Format a raw `Pattern` into a string. `args` will be used to resolve\n     * references to variables passed as arguments to the translation.\n     *\n     * In case of errors `formatPattern` will try to salvage as much of the\n     * translation as possible and will still return a string. For performance\n     * reasons, the encountered errors are not returned but instead are appended\n     * to the `errors` array passed as the third argument.\n     *\n     *     let errors = [];\n     *     bundle.addResource(\n     *         new FluentResource(\"hello = Hello, {$name}!\"));\n     *\n     *     let hello = bundle.getMessage(\"hello\");\n     *     if (hello.value) {\n     *         bundle.formatPattern(hello.value, {name: \"Jane\"}, errors);\n     *         // Returns \"Hello, Jane!\" and `errors` is empty.\n     *\n     *         bundle.formatPattern(hello.value, undefined, errors);\n     *         // Returns \"Hello, {$name}!\" and `errors` is now:\n     *         // [<ReferenceError: Unknown variable: name>]\n     *     }\n     *\n     * If `errors` is omitted, the first encountered error will be thrown.\n     */\n    formatPattern(pattern, args = null, errors = null) {\n        // Resolve a simple pattern without creating a scope. No error handling is\n        // required; by definition simple patterns don't have placeables.\n        if (typeof pattern === \"string\") {\n            return this._transform(pattern);\n        }\n        // Resolve a complex pattern.\n        let scope = new Scope(this, errors, args);\n        try {\n            let value = resolveComplexPattern(scope, pattern);\n            return value.toString(scope);\n        }\n        catch (err) {\n            if (scope.errors && err instanceof Error) {\n                scope.errors.push(err);\n                return new FluentNone().toString(scope);\n            }\n            throw err;\n        }\n    }\n}\n","// This regex is used to iterate through the beginnings of messages and terms.\n// With the /m flag, the ^ matches at the beginning of every line.\nconst RE_MESSAGE_START = /^(-?[a-zA-Z][\\w-]*) *= */gm;\n// Both Attributes and Variants are parsed in while loops. These regexes are\n// used to break out of them.\nconst RE_ATTRIBUTE_START = /\\.([a-zA-Z][\\w-]*) *= */y;\nconst RE_VARIANT_START = /\\*?\\[/y;\nconst RE_NUMBER_LITERAL = /(-?[0-9]+(?:\\.([0-9]+))?)/y;\nconst RE_IDENTIFIER = /([a-zA-Z][\\w-]*)/y;\nconst RE_REFERENCE = /([$-])?([a-zA-Z][\\w-]*)(?:\\.([a-zA-Z][\\w-]*))?/y;\nconst RE_FUNCTION_NAME = /^[A-Z][A-Z0-9_-]*$/;\n// A \"run\" is a sequence of text or string literal characters which don't\n// require any special handling. For TextElements such special characters are: {\n// (starts a placeable), and line breaks which require additional logic to check\n// if the next line is indented. For StringLiterals they are: \\ (starts an\n// escape sequence), \" (ends the literal), and line breaks which are not allowed\n// in StringLiterals. Note that string runs may be empty; text runs may not.\nconst RE_TEXT_RUN = /([^{}\\n\\r]+)/y;\nconst RE_STRING_RUN = /([^\\\\\"\\n\\r]*)/y;\n// Escape sequences.\nconst RE_STRING_ESCAPE = /\\\\([\\\\\"])/y;\nconst RE_UNICODE_ESCAPE = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{6})/y;\n// Used for trimming TextElements and indents.\nconst RE_LEADING_NEWLINES = /^\\n+/;\nconst RE_TRAILING_SPACES = / +$/;\n// Used in makeIndent to strip spaces from blank lines and normalize CRLF to LF.\nconst RE_BLANK_LINES = / *\\r?\\n/g;\n// Used in makeIndent to measure the indentation.\nconst RE_INDENT = /( *)$/;\n// Common tokens.\nconst TOKEN_BRACE_OPEN = /{\\s*/y;\nconst TOKEN_BRACE_CLOSE = /\\s*}/y;\nconst TOKEN_BRACKET_OPEN = /\\[\\s*/y;\nconst TOKEN_BRACKET_CLOSE = /\\s*] */y;\nconst TOKEN_PAREN_OPEN = /\\s*\\(\\s*/y;\nconst TOKEN_ARROW = /\\s*->\\s*/y;\nconst TOKEN_COLON = /\\s*:\\s*/y;\n// Note the optional comma. As a deviation from the Fluent EBNF, the parser\n// doesn't enforce commas between call arguments.\nconst TOKEN_COMMA = /\\s*,?\\s*/y;\nconst TOKEN_BLANK = /\\s+/y;\n/**\n * Fluent Resource is a structure storing parsed localization entries.\n */\nexport class FluentResource {\n    constructor(source) {\n        this.body = [];\n        RE_MESSAGE_START.lastIndex = 0;\n        let cursor = 0;\n        // Iterate over the beginnings of messages and terms to efficiently skip\n        // comments and recover from errors.\n        while (true) {\n            let next = RE_MESSAGE_START.exec(source);\n            if (next === null) {\n                break;\n            }\n            cursor = RE_MESSAGE_START.lastIndex;\n            try {\n                this.body.push(parseMessage(next[1]));\n            }\n            catch (err) {\n                if (err instanceof SyntaxError) {\n                    // Don't report any Fluent syntax errors. Skip directly to the\n                    // beginning of the next message or term.\n                    continue;\n                }\n                throw err;\n            }\n        }\n        // The parser implementation is inlined below for performance reasons,\n        // as well as for convenience of accessing `source` and `cursor`.\n        // The parser focuses on minimizing the number of false negatives at the\n        // expense of increasing the risk of false positives. In other words, it\n        // aims at parsing valid Fluent messages with a success rate of 100%, but it\n        // may also parse a few invalid messages which the reference parser would\n        // reject. The parser doesn't perform any validation and may produce entries\n        // which wouldn't make sense in the real world. For best results users are\n        // advised to validate translations with the fluent-syntax parser\n        // pre-runtime.\n        // The parser makes an extensive use of sticky regexes which can be anchored\n        // to any offset of the source string without slicing it. Errors are thrown\n        // to bail out of parsing of ill-formed messages.\n        function test(re) {\n            re.lastIndex = cursor;\n            return re.test(source);\n        }\n        // Advance the cursor by the char if it matches. May be used as a predicate\n        // (was the match found?) or, if errorClass is passed, as an assertion.\n        function consumeChar(char, errorClass) {\n            if (source[cursor] === char) {\n                cursor++;\n                return true;\n            }\n            if (errorClass) {\n                throw new errorClass(`Expected ${char}`);\n            }\n            return false;\n        }\n        // Advance the cursor by the token if it matches. May be used as a predicate\n        // (was the match found?) or, if errorClass is passed, as an assertion.\n        function consumeToken(re, errorClass) {\n            if (test(re)) {\n                cursor = re.lastIndex;\n                return true;\n            }\n            if (errorClass) {\n                throw new errorClass(`Expected ${re.toString()}`);\n            }\n            return false;\n        }\n        // Execute a regex, advance the cursor, and return all capture groups.\n        function match(re) {\n            re.lastIndex = cursor;\n            let result = re.exec(source);\n            if (result === null) {\n                throw new SyntaxError(`Expected ${re.toString()}`);\n            }\n            cursor = re.lastIndex;\n            return result;\n        }\n        // Execute a regex, advance the cursor, and return the capture group.\n        function match1(re) {\n            return match(re)[1];\n        }\n        function parseMessage(id) {\n            let value = parsePattern();\n            let attributes = parseAttributes();\n            if (value === null && Object.keys(attributes).length === 0) {\n                throw new SyntaxError(\"Expected message value or attributes\");\n            }\n            return { id, value, attributes };\n        }\n        function parseAttributes() {\n            let attrs = Object.create(null);\n            while (test(RE_ATTRIBUTE_START)) {\n                let name = match1(RE_ATTRIBUTE_START);\n                let value = parsePattern();\n                if (value === null) {\n                    throw new SyntaxError(\"Expected attribute value\");\n                }\n                attrs[name] = value;\n            }\n            return attrs;\n        }\n        function parsePattern() {\n            let first;\n            // First try to parse any simple text on the same line as the id.\n            if (test(RE_TEXT_RUN)) {\n                first = match1(RE_TEXT_RUN);\n            }\n            // If there's a placeable on the first line, parse a complex pattern.\n            if (source[cursor] === \"{\" || source[cursor] === \"}\") {\n                // Re-use the text parsed above, if possible.\n                return parsePatternElements(first ? [first] : [], Infinity);\n            }\n            // RE_TEXT_VALUE stops at newlines. Only continue parsing the pattern if\n            // what comes after the newline is indented.\n            let indent = parseIndent();\n            if (indent) {\n                if (first) {\n                    // If there's text on the first line, the blank block is part of the\n                    // translation content in its entirety.\n                    return parsePatternElements([first, indent], indent.length);\n                }\n                // Otherwise, we're dealing with a block pattern, i.e. a pattern which\n                // starts on a new line. Discrad the leading newlines but keep the\n                // inline indent; it will be used by the dedentation logic.\n                indent.value = trim(indent.value, RE_LEADING_NEWLINES);\n                return parsePatternElements([indent], indent.length);\n            }\n            if (first) {\n                // It was just a simple inline text after all.\n                return trim(first, RE_TRAILING_SPACES);\n            }\n            return null;\n        }\n        // Parse a complex pattern as an array of elements.\n        function parsePatternElements(elements = [], commonIndent) {\n            while (true) {\n                if (test(RE_TEXT_RUN)) {\n                    elements.push(match1(RE_TEXT_RUN));\n                    continue;\n                }\n                if (source[cursor] === \"{\") {\n                    elements.push(parsePlaceable());\n                    continue;\n                }\n                if (source[cursor] === \"}\") {\n                    throw new SyntaxError(\"Unbalanced closing brace\");\n                }\n                let indent = parseIndent();\n                if (indent) {\n                    elements.push(indent);\n                    commonIndent = Math.min(commonIndent, indent.length);\n                    continue;\n                }\n                break;\n            }\n            let lastIndex = elements.length - 1;\n            let lastElement = elements[lastIndex];\n            // Trim the trailing spaces in the last element if it's a TextElement.\n            if (typeof lastElement === \"string\") {\n                elements[lastIndex] = trim(lastElement, RE_TRAILING_SPACES);\n            }\n            let baked = [];\n            for (let element of elements) {\n                if (element instanceof Indent) {\n                    // Dedent indented lines by the maximum common indent.\n                    element = element.value.slice(0, element.value.length - commonIndent);\n                }\n                if (element) {\n                    baked.push(element);\n                }\n            }\n            return baked;\n        }\n        function parsePlaceable() {\n            consumeToken(TOKEN_BRACE_OPEN, SyntaxError);\n            let selector = parseInlineExpression();\n            if (consumeToken(TOKEN_BRACE_CLOSE)) {\n                return selector;\n            }\n            if (consumeToken(TOKEN_ARROW)) {\n                let variants = parseVariants();\n                consumeToken(TOKEN_BRACE_CLOSE, SyntaxError);\n                return {\n                    type: \"select\",\n                    selector,\n                    ...variants\n                };\n            }\n            throw new SyntaxError(\"Unclosed placeable\");\n        }\n        function parseInlineExpression() {\n            if (source[cursor] === \"{\") {\n                // It's a nested placeable.\n                return parsePlaceable();\n            }\n            if (test(RE_REFERENCE)) {\n                let [, sigil, name, attr = null] = match(RE_REFERENCE);\n                if (sigil === \"$\") {\n                    return { type: \"var\", name };\n                }\n                if (consumeToken(TOKEN_PAREN_OPEN)) {\n                    let args = parseArguments();\n                    if (sigil === \"-\") {\n                        // A parameterized term: -term(...).\n                        return { type: \"term\", name, attr, args };\n                    }\n                    if (RE_FUNCTION_NAME.test(name)) {\n                        return { type: \"func\", name, args };\n                    }\n                    throw new SyntaxError(\"Function names must be all upper-case\");\n                }\n                if (sigil === \"-\") {\n                    // A non-parameterized term: -term.\n                    return {\n                        type: \"term\",\n                        name,\n                        attr,\n                        args: []\n                    };\n                }\n                return { type: \"mesg\", name, attr };\n            }\n            return parseLiteral();\n        }\n        function parseArguments() {\n            let args = [];\n            while (true) {\n                switch (source[cursor]) {\n                    case \")\": // End of the argument list.\n                        cursor++;\n                        return args;\n                    case undefined: // EOF\n                        throw new SyntaxError(\"Unclosed argument list\");\n                }\n                args.push(parseArgument());\n                // Commas between arguments are treated as whitespace.\n                consumeToken(TOKEN_COMMA);\n            }\n        }\n        function parseArgument() {\n            let expr = parseInlineExpression();\n            if (expr.type !== \"mesg\") {\n                return expr;\n            }\n            if (consumeToken(TOKEN_COLON)) {\n                // The reference is the beginning of a named argument.\n                return {\n                    type: \"narg\",\n                    name: expr.name,\n                    value: parseLiteral()\n                };\n            }\n            // It's a regular message reference.\n            return expr;\n        }\n        function parseVariants() {\n            let variants = [];\n            let count = 0;\n            let star;\n            while (test(RE_VARIANT_START)) {\n                if (consumeChar(\"*\")) {\n                    star = count;\n                }\n                let key = parseVariantKey();\n                let value = parsePattern();\n                if (value === null) {\n                    throw new SyntaxError(\"Expected variant value\");\n                }\n                variants[count++] = { key, value };\n            }\n            if (count === 0) {\n                return null;\n            }\n            if (star === undefined) {\n                throw new SyntaxError(\"Expected default variant\");\n            }\n            return { variants, star };\n        }\n        function parseVariantKey() {\n            consumeToken(TOKEN_BRACKET_OPEN, SyntaxError);\n            let key;\n            if (test(RE_NUMBER_LITERAL)) {\n                key = parseNumberLiteral();\n            }\n            else {\n                key = {\n                    type: \"str\",\n                    value: match1(RE_IDENTIFIER)\n                };\n            }\n            consumeToken(TOKEN_BRACKET_CLOSE, SyntaxError);\n            return key;\n        }\n        function parseLiteral() {\n            if (test(RE_NUMBER_LITERAL)) {\n                return parseNumberLiteral();\n            }\n            if (source[cursor] === '\"') {\n                return parseStringLiteral();\n            }\n            throw new SyntaxError(\"Invalid expression\");\n        }\n        function parseNumberLiteral() {\n            let [, value, fraction = \"\"] = match(RE_NUMBER_LITERAL);\n            let precision = fraction.length;\n            return {\n                type: \"num\",\n                value: parseFloat(value),\n                precision\n            };\n        }\n        function parseStringLiteral() {\n            consumeChar('\"', SyntaxError);\n            let value = \"\";\n            while (true) {\n                value += match1(RE_STRING_RUN);\n                if (source[cursor] === \"\\\\\") {\n                    value += parseEscapeSequence();\n                    continue;\n                }\n                if (consumeChar('\"')) {\n                    return { type: \"str\", value };\n                }\n                // We've reached an EOL of EOF.\n                throw new SyntaxError(\"Unclosed string literal\");\n            }\n        }\n        // Unescape known escape sequences.\n        function parseEscapeSequence() {\n            if (test(RE_STRING_ESCAPE)) {\n                return match1(RE_STRING_ESCAPE);\n            }\n            if (test(RE_UNICODE_ESCAPE)) {\n                let [, codepoint4, codepoint6] = match(RE_UNICODE_ESCAPE);\n                let codepoint = parseInt(codepoint4 || codepoint6, 16);\n                return codepoint <= 0xd7ff || 0xe000 <= codepoint\n                    // It's a Unicode scalar value.\n                    ? String.fromCodePoint(codepoint)\n                    // Lonely surrogates can cause trouble when the parsing result is\n                    // saved using UTF-8. Use U+FFFD REPLACEMENT CHARACTER instead.\n                    : \"\";\n            }\n            throw new SyntaxError(\"Unknown escape sequence\");\n        }\n        // Parse blank space. Return it if it looks like indent before a pattern\n        // line. Skip it othwerwise.\n        function parseIndent() {\n            let start = cursor;\n            consumeToken(TOKEN_BLANK);\n            // Check the first non-blank character after the indent.\n            switch (source[cursor]) {\n                case \".\":\n                case \"[\":\n                case \"*\":\n                case \"}\":\n                case undefined: // EOF\n                    // A special character. End the Pattern.\n                    return false;\n                case \"{\":\n                    // Placeables don't require indentation (in EBNF: block-placeable).\n                    // Continue the Pattern.\n                    return makeIndent(source.slice(start, cursor));\n            }\n            // If the first character on the line is not one of the special characters\n            // listed above, it's a regular text character. Check if there's at least\n            // one space of indent before it.\n            if (source[cursor - 1] === \" \") {\n                // It's an indented text character (in EBNF: indented-char). Continue\n                // the Pattern.\n                return makeIndent(source.slice(start, cursor));\n            }\n            // A not-indented text character is likely the identifier of the next\n            // message. End the Pattern.\n            return false;\n        }\n        // Trim blanks in text according to the given regex.\n        function trim(text, re) {\n            return text.replace(re, \"\");\n        }\n        // Normalize a blank block and extract the indent details.\n        function makeIndent(blank) {\n            let value = blank.replace(RE_BLANK_LINES, \"\\n\");\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            let length = RE_INDENT.exec(blank)[1].length;\n            return new Indent(value, length);\n        }\n    }\n}\nclass Indent {\n    constructor(value, length) {\n        this.value = value;\n        this.length = length;\n    }\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = memoize;\n","import memoize from 'lodash.memoize';\nfunction resolver(options) {\n    return JSON.stringify(options);\n}\nfunction uniqDefined(arr) {\n    return arr.filter(function (el, index) { return el && arr.indexOf(el) === index; });\n}\nfunction isAllLowerCase(el) {\n    return el.toLowerCase() === el;\n}\nfunction normalizeLocale(el) {\n    if (!el || el.indexOf('-') === -1 || !isAllLowerCase(el)) {\n        return el;\n    }\n    var _a = el.split('-'), _b = _a[0], splitEl1 = _b === void 0 ? '' : _b, _c = _a[1], splitEl2 = _c === void 0 ? '' : _c;\n    return \"\".concat(splitEl1, \"-\").concat(splitEl2.toUpperCase());\n}\nfunction getUserLocalesInternal(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.useFallbackLocale, useFallbackLocale = _c === void 0 ? true : _c, _d = _b.fallbackLocale, fallbackLocale = _d === void 0 ? 'en-US' : _d;\n    var languageList = [];\n    if (typeof navigator !== 'undefined') {\n        languageList = languageList.concat(navigator.languages, navigator.language);\n    }\n    if (useFallbackLocale) {\n        languageList.push(fallbackLocale);\n    }\n    return uniqDefined(languageList).map(normalizeLocale);\n}\nexport var getUserLocales = memoize(getUserLocalesInternal, resolver);\nfunction getUserLocaleInternal(options) {\n    return getUserLocales(options)[0] || null;\n}\nexport var getUserLocale = memoize(getUserLocaleInternal, resolver);\nexport default getUserLocale;\n","import { Localization, DOMLocalization } from \"@fluent/dom\";\r\nimport { FluentBundle, FluentResource } from \"@fluent/bundle\";\r\nimport getUserLocales from 'get-user-locale'\r\n\r\n\r\nasync function fetch_resource(locale, resourceId) {\r\n    locale = locale.replace(\"-\", \"_\") // Make Anvil-Compatible path\r\n    const url = resourceId.replace(\"{locale}\", locale);\r\n    const response = await fetch(url);\r\n    const text = await response.text();\r\n    return new FluentResource(text);\r\n  }\r\n\r\nasync function create_bundle(locale, resourceId, errors) {\r\n    let resource = await fetch_resource(locale, resourceId);\r\n    let bundle = new FluentBundle(locale);\r\n    errors.entries += bundle.addResource(resource);\r\n\r\n    // Output errors, if any.\r\n    for (const entry of errors.entries) {\r\n      console.log(\"Error creating bundle for locale \" + locale + entry)\r\n    }\r\n    return bundle;\r\n}\r\n\r\nfunction create_bundle_generator(locale, fallback_locales, errors){\r\n    return async function* generate_bundles(resourceIds) {\r\n        yield await create_bundle(locale, resourceIds[0], errors);\r\n      \r\n        for (const entry of fallback_locales) {\r\n          yield await create_bundle(entry, resourceIds[0], errors);\r\n        }\r\n    }\r\n} \r\n\r\nexport function get_user_locales(fallback){\r\n  if (fallback){\r\n    return getUserLocales({fallbackLocale: fallback, useFallbackLocale: true})\r\n  }\r\n  return getUserLocales()  \r\n}\r\n\r\nexport function init_localization(resource_path_template, locale, fallback_locales){\r\n  let dom_errors = {entries: []}\r\n  let main_errors = {entries: []}  \r\n  \r\n  const dom_bundle_gen = create_bundle_generator(locale, fallback_locales, dom_errors)\r\n  const loc_bundle_gen = create_bundle_generator(locale, fallback_locales, main_errors)\r\n    \r\n    \r\n  // Activate DOM localization\r\n  const dom = new DOMLocalization(\r\n      [resource_path_template], \r\n      dom_bundle_gen\r\n  );\r\n  dom.connectRoot(document.documentElement);\r\n  dom.translateRoots(); \r\n\r\n  const main = new Localization([resource_path_template], loc_bundle_gen)\r\n\r\n  return {\r\n    dom: dom, \r\n    dom_errors: dom_errors.entries,\r\n    main: main, \r\n    main_errors: main_errors.entries\r\n  }\r\n}\r\n\r\n"],"names":["$aa1aea98d5cc494a$var$reOverlay","$aa1aea98d5cc494a$var$TEXT_LEVEL_ELEMENTS","$aa1aea98d5cc494a$var$LOCALIZABLE_ATTRIBUTES","global","a","area","input","menuitem","menu","optgroup","option","track","img","textarea","th","description","key","label","textbox","$aa1aea98d5cc494a$export$2e2bcd8739ae039","element","translation","value","localName","namespaceURI","textContent","test","templateElement","ownerDocument","createElementNS","innerHTML","fromFragment","toElement","childNode","childNodes","nodeType","TEXT_NODE","hasAttribute","sanitized","$aa1aea98d5cc494a$var$getNodeForNamedElement","replaceChild","$aa1aea98d5cc494a$var$isElementAllowed","$aa1aea98d5cc494a$var$createSanitizedElement","console","warn","$aa1aea98d5cc494a$var$createTextNodeFromTextContent","appendChild","$aa1aea98d5cc494a$var$overlayChildNodes","content","$aa1aea98d5cc494a$var$overlayAttributes","$aa1aea98d5cc494a$var$hasAttribute","attributes","name","attr","fromElement","explicitlyAllowed","getAttribute","split","map","i","trim","Array","from","$aa1aea98d5cc494a$var$isAttrNameLocalizable","removeAttribute","setAttribute","sourceElement","translatedChild","childName","sourceChild","querySelector","removeChild","$aa1aea98d5cc494a$var$shallowPopulateUsing","cloneNode","clone","createElement","createTextNode","allowed","includes","attrName","toLowerCase","elemName","type","$8800bd0af9949c63$export$2e2bcd8739ae039","static","iterable","this","$fb5bb584604d5d8b$export$2e2bcd8739ae039","constructor","super","Symbol","iterator","Object","TypeError","cached","cur","next","length","push","touchNext","count","idx","last","done","$f1f93a431a6c52e2$export$2e2bcd8739ae039","asyncIterator","async","$a8c46d7c2aaff594$export$2e2bcd8739ae039","resourceIds","generateBundles","onChange","addResourceIds","eager","removeResourceIds","filter","r","keys","method","translations","hasAtLeastOneBundle","bundle","bundles","missingIds","$a8c46d7c2aaff594$var$keysFromBundle","size","locale","locales","ids","join","JSON","stringify","formatMessages","formatWithFallback","$a8c46d7c2aaff594$var$messageFromBundle","formatValues","$a8c46d7c2aaff594$var$valueFromBundle","id","args","val","handleEvent","errors","message","formatPattern","formatted","attrNames","entries","messageErrors","Set","forEach","undefined","getMessage","add","$2ca34dec5b1190bc$var$L10NID_ATTR_NAME","$2ca34dec5b1190bc$var$L10NARGS_ATTR_NAME","$2ca34dec5b1190bc$var$L10N_ELEMENT_QUERY","$2ca34dec5b1190bc$export$2e2bcd8739ae039","roots","pendingrAF","pendingElements","windowElement","mutationObserver","observerConfig","characterData","childList","subtree","attributeFilter","translateRoots","setAttributes","getAttributes","parse","connectRoot","newRoot","root","contains","Error","defaultView","MutationObserver","mutations","translateMutations","observe","disconnectRoot","delete","pauseObserving","clear","resumeObserving","Promise","all","translateFragment","takeRecords","disconnect","mutation","target","addedNode","addedNodes","ELEMENT_NODE","childElementCount","getTranslatables","requestAnimationFrame","translateElements","frag","elements","getKeysForElement","applyTranslations","nodes","querySelectorAll","$08b6f83ae380fa95$export$86bd9bf8a2206303","valueOf","$08b6f83ae380fa95$export$74a88f5da61fec15","toString","scope","$08b6f83ae380fa95$export$bb167d788a5da036","opts","memoizeIntlObject","Intl","NumberFormat","format","err","reportError","$08b6f83ae380fa95$export$3756696568ce9bad","DateTimeFormat","Date","toISOString","$2ad0d42a4322a2aa$var$MAX_PLACEABLES","$2ad0d42a4322a2aa$var$FSI","$2ad0d42a4322a2aa$var$PDI","$2ad0d42a4322a2aa$var$match","selector","PluralRules","select","$2ad0d42a4322a2aa$var$getDefault","variants","star","$2ad0d42a4322a2aa$var$resolvePattern","RangeError","$2ad0d42a4322a2aa$var$getArguments","positional","named","create","arg","$2ad0d42a4322a2aa$var$resolveExpression","expr","minimumFractionDigits","precision","params","prototype","hasOwnProperty","call","ReferenceError","getTime","$2ad0d42a4322a2aa$var$resolveVariableReference","_messages","get","attribute","$2ad0d42a4322a2aa$var$resolveMessageReference","term","_terms","resolved","$2ad0d42a4322a2aa$var$resolveTermReference","func","_functions","$2ad0d42a4322a2aa$var$resolveFunctionReference","sel","variant","$2ad0d42a4322a2aa$var$resolveSelectExpression","$2ad0d42a4322a2aa$export$99cfa860dd34571c","ptn","dirty","has","result","useIsolating","_useIsolating","elem","placeables","_transform","$279304c83969ae7a$export$775b6bb06e53a214","WeakSet","error","ctor","cache","_intls","set","$a48237c5acde9708$var$values","unwrapped","opt","$a48237c5acde9708$var$NUMBER_ALLOWED","$a48237c5acde9708$export$4e8bcd47a31d751c","$a48237c5acde9708$var$DATETIME_ALLOWED","$a48237c5acde9708$export$b72dfaf482d1f75b","$593c449a3ef089e8$var$cache","Map","$593c449a3ef089e8$export$12a7cb8fe9f8fff9","stringLocale","isArray","memoizer","$1901033e2d251b1f$export$dbb69eb03354692e","functions","transform","v","hasMessage","addResource","res","allowOverrides","body","entry","startsWith","pattern","$d4b24a058c8b41c2$var$RE_MESSAGE_START","$d4b24a058c8b41c2$var$RE_ATTRIBUTE_START","$d4b24a058c8b41c2$var$RE_VARIANT_START","$d4b24a058c8b41c2$var$RE_NUMBER_LITERAL","$d4b24a058c8b41c2$var$RE_IDENTIFIER","$d4b24a058c8b41c2$var$RE_REFERENCE","$d4b24a058c8b41c2$var$RE_FUNCTION_NAME","$d4b24a058c8b41c2$var$RE_TEXT_RUN","$d4b24a058c8b41c2$var$RE_STRING_RUN","$d4b24a058c8b41c2$var$RE_STRING_ESCAPE","$d4b24a058c8b41c2$var$RE_UNICODE_ESCAPE","$d4b24a058c8b41c2$var$RE_LEADING_NEWLINES","$d4b24a058c8b41c2$var$RE_TRAILING_SPACES","$d4b24a058c8b41c2$var$RE_BLANK_LINES","$d4b24a058c8b41c2$var$RE_INDENT","$d4b24a058c8b41c2$var$TOKEN_BRACE_OPEN","$d4b24a058c8b41c2$var$TOKEN_BRACE_CLOSE","$d4b24a058c8b41c2$var$TOKEN_BRACKET_OPEN","$d4b24a058c8b41c2$var$TOKEN_BRACKET_CLOSE","$d4b24a058c8b41c2$var$TOKEN_PAREN_OPEN","$d4b24a058c8b41c2$var$TOKEN_ARROW","$d4b24a058c8b41c2$var$TOKEN_COLON","$d4b24a058c8b41c2$var$TOKEN_COMMA","$d4b24a058c8b41c2$var$TOKEN_BLANK","$d4b24a058c8b41c2$export$ce122eb5f5b1d45d","source","lastIndex","cursor","exec","parseMessage","SyntaxError","re","consumeChar","char","errorClass","consumeToken","match","match1","parsePattern","attrs","parseAttributes","first","parsePatternElements","Infinity","indent","parseIndent","commonIndent","parsePlaceable","Math","min","lastElement","baked","$d4b24a058c8b41c2$var$Indent","slice","parseInlineExpression","parseVariantKey","parseVariants","sigil","parseArgument","parseArguments","parseLiteral","parseNumberLiteral","parseEscapeSequence","parseStringLiteral","fraction","parseFloat","codepoint4","codepoint6","codepoint","parseInt","String","fromCodePoint","start","makeIndent","text","replace","blank","$d07ab8501ccb2337$var$FUNC_ERROR_TEXT","$d07ab8501ccb2337$var$HASH_UNDEFINED","$d07ab8501ccb2337$var$funcTag","$d07ab8501ccb2337$var$genTag","$d07ab8501ccb2337$var$reIsHostCtor","$d07ab8501ccb2337$var$freeGlobal","$parcel$global","$d07ab8501ccb2337$var$freeSelf","self","$d07ab8501ccb2337$var$root","Function","uid","$d07ab8501ccb2337$var$arrayProto","$d07ab8501ccb2337$var$funcProto","$d07ab8501ccb2337$var$objectProto","$d07ab8501ccb2337$var$coreJsData","$d07ab8501ccb2337$var$maskSrcKey","IE_PROTO","$d07ab8501ccb2337$var$funcToString","$d07ab8501ccb2337$var$hasOwnProperty","$d07ab8501ccb2337$var$objectToString","$d07ab8501ccb2337$var$reIsNative","RegExp","$d07ab8501ccb2337$var$splice","splice","$d07ab8501ccb2337$var$Map","$d07ab8501ccb2337$var$getNative","$d07ab8501ccb2337$var$nativeCreate","$d07ab8501ccb2337$var$Hash","index","$d07ab8501ccb2337$var$ListCache","$d07ab8501ccb2337$var$MapCache","$d07ab8501ccb2337$var$assocIndexOf","array","other","$d07ab8501ccb2337$var$baseIsNative","$d07ab8501ccb2337$var$isObject","tag","$d07ab8501ccb2337$var$isFunction","e","$d07ab8501ccb2337$var$isHostObject","$d07ab8501ccb2337$var$toSource","$d07ab8501ccb2337$var$getMapData","data","__data__","object","$d07ab8501ccb2337$var$getValue","$d07ab8501ccb2337$var$memoize","resolver","memoized","arguments","apply","Cache","$68d74f8c885a4574$var$resolver","options","$68d74f8c885a4574$var$normalizeLocale","el","indexOf","$68d74f8c885a4574$var$isAllLowerCase","_a","_b","splitEl1","_c","splitEl2","concat","toUpperCase","pop","hash","string","$68d74f8c885a4574$export$2709d88c05bbce73","$parcel$interopDefault","$d07ab8501ccb2337$exports","arr","useFallbackLocale","_d","fallbackLocale","languageList","navigator","languages","language","$68d74f8c885a4574$export$2e2bcd8739ae039","$d7402a2be22205ce$var$create_bundle","resourceId","resource","url","response","fetch","$d7402a2be22205ce$var$fetch_resource","log","$d7402a2be22205ce$var$create_bundle_generator","fallback_locales","$d7402a2be22205ce$export$f682872cc4c41f5a","fallback","$d7402a2be22205ce$export$9ad5513bfd235f86","resource_path_template","dom_errors","main_errors","dom_bundle_gen","loc_bundle_gen","dom","document","documentElement","main"],"version":3,"file":"fluent_anvil.js.map"}